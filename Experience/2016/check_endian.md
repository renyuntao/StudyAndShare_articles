# 如何检查字节序?          
<!--
2016-08-23
--> <br /><br />

## 什么是字节序?       

下面是摘自维基百科中文版中关于 **[字节序](https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F)** 的一段描述:              

> 在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为int的变量x地址为0x100，那么其对应地址表达式&x的值为0x100。且x的四个字节将被存储在存储器的0x100, 0x101, 0x102, 0x103位置。          
>             
> 而存储地址内的排列则有两个通用规则。一个多位的整数将按照其存储地址的最低或最高字节排列。如果最低有效位在最高有效位的前面，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。          
>       
> 例如假设上述变量x类型为int，位于地址0x100处，它的十六进制为0x01234567，地址范围为0x100~0x103字节，其内部排列顺序依赖于机器的类型。大端法从首位开始将是：0x100: 01, 0x101: 23,..。而小端法将是：0x100: 67, 0x101: 45,..。      

关于字节序的详细介绍，可以参见维基百科。                

**注意:** 维基百科中文版已被朝廷封锁，不过维基百科英文版还可以在天朝里正常访问，如果你暂时还不能突破朝廷的封锁，可以查看 **[维基百科英文版中关于字节序的介绍](https://en.wikipedia.org/wiki/Endianness)** 。**其实，即使你能够突破朝廷的封锁，我还是推荐你看维基百科英文版，因为维基百科英文版的相关介绍要比维基百科中文版中的介绍详细很多**。                              

--------------------

## 为什么要检查字节序?                           

在某些情况下，你要在你的机器上完成一些事情，首先需要知道你的机器是按照大端序(**Big-endian**)来存储多字节数据还按照小端序(**Little-endian**)来存储多字节数据的。例如，我在 **[如何将一个十进制整数以二进制的格式输出?](how_to_print_integer_as_binary.html)** 一文中介绍如何在C/C++中将一个十进制数转换为二进制数来输出时，就涉及到了字节序的问题，当时是假定以小端序(**Little-endian**)的方式来存储数据的，这也是多数机器的数据存储方式。但最好你还是应该检查下你的机器的数据存储方式，如果是以大端序的方式来存储数据的，那么，你需要对那篇文章中的程序做一些修改, 才能得到预期的结果。               

推荐阅读: **[如何将一个十进制整数以二进制的格式输出?](how_to_print_integer_as_binary.html)**           

--------------------

## 如何检查字节序?             

下面介绍几种在Linux和 Windows 系统中检查字节序的简单方法。                   

### Linux系统中的检查方法       

下面所说的方法是针对Linux系统而言的，不能在Windows系统中使用。               
            
#### 方法一

首先打开终端，在终端中输入下面的任意一条命令并执行:           

```bash
$ echo -n "I" | od -to2 | head -1 | cut -d " " -f 2 | cut -c 6
```
或

```bash
$ echo -n "I" | od -to2 | awk 'NR == 1 {print substr($2,6,1)}'
```

如果上面的命令的输出结果是 `1`, 则表示你的机器是以小端序(**Little-endian**)来存储数据的; 而如果上面的命令的输出结果是 `0`, 则表示你的机器是以大端序(**Big-endian**)的方式来存储数据的。              

#### 方法二

打开终端，在终端输入如下命令并执行:             

```bash
$ lscpu | grep 'Endian'
```
在以小端序的方式来存储数据的机器上，会得到如下结果:           

```bash
Byte Order:            Little Endian
```
而以大端序的方式来存储数据的机器上，则会得到下面的结果:            

```bash
Byte Order:            Big Endian
```

### Windows系统中的检查方法           

虽然标题是Windows系统中的检查方法，但下面所说的方法在Linux和Windows系统中是通用的，即下面的方法也可以在Linux系统中使用。              

这个方法十分简单，编译并运行下面的 C++ 程序即可:          

```cpp
#include<iostream>

int main()
{
	int num = 1;
	if(*((char*)&num) == 1)
		std::cout<<"Little-endian"<<"\n";
	else
		std::cout<<"Big-endian"<<"\n";

	return 0;
}
```

如果输出结果是 `Little-endian`, 则表示你的机器是以小端序的方式来存储数据的; 而如果输出结果是 `Big-endian`, 则表示你的机器是以大端序的方式来存储数据的。                 

----------------------

## 结束语

机器的字节序决定了数据在内存中的存储方式，有时候，数据在内存中存储的方式决定了我们所要处理的问题的解决方式（例如，我在上面提到的十进制数转换为二进制格式来输出的问题）。这篇文章中简单介绍了字节序的概念，获取机器的字节序的原因，以及在Linux和Windows系统中获取机器字节序的几种方法，希望可以帮助到你。             

<!--
Reference:
https://serverfault.com/questions/163487/how-to-tell-if-a-linux-system-is-big-endian-or-little-endian

https://stackoverflow.com/questions/8571089/how-can-i-find-endian-ness-of-my-pc-programmatically-using-c
-->
