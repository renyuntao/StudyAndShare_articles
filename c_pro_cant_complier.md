# 不能被C++编译器编译的C程序
2015-10-27 <br />    
虽然C++被设计为向后兼容C，但是仍然有很多C程序在被C++编译器编译时会产生编译错误，二者毕竟不是同一种语言。下面是其中的一些情况。     
<br />
**1)**在C++中使用字符串字面值为字符数组赋值时会自动在字符串末尾添加空字符`\0`,因此字符数组要为这个`\0`留出空间;然而在C中，使用字符串字面值为字符数组赋值时，却不会在字符串末尾自动添加空字符`\0`.因此，下面的C程序在C编译器下可以正常编译，但是在C++编译器下则会报错:   

    char arr[][5] = {"hello","world"};   //用C++编译器编译时需要将arr[][5]改为arr[][6]
    printf("%c",arr[0][0]);
<hr /><br />
**2)**在C++中，将一个普通指针指向一个常量，会导致编译错误;但是在C中，将一个普通指针指向一个常量，C编译器会发出警告，但是仍然能够通过编译，如下:   

	//在C编译器下可以通过编译，但是在C++编译器下则不能
    const int a = 5;
    int *p = &a;
<hr /><br />
**3)**该种情况与第二种情况相似，即在C++中，你不能在声明一个函数以前调用一个函数，这样会导致编译器报错，从而导致编译失败;然而在C中，C编译器同样只是发出警告，但仍然会通过编译，下面的程序在C编译器下可以通过编译，而在C++编译器下却不能:    

    #include<stdio.h>
    
    int main()
    {
    	foo();
    	return 0;
    }
    
    void foo()
    {
    	printf("Hello World\n");
    }
<hr /><br />
**4)**在C中，一个空指针可以直接赋值给其他类型的指针，如`int*`,`char*`等，但是在C++中却不能这么做，你不需要明确地将void指针转换为被赋值的指针类型，因为C++中有如下一条规则:

>“一般情况下，对指针进行赋值时，等号两边的指针类型要相同。”

因此，下面程序只能在C编译器下编译通过，而在C++编译器下进行编译则会导致编译失败:     

    void *vp;
    int *p = vp;  //将该语句改为int *p = (int*)vp;即可在C++编译器下编译成功
同理，当使用`malloc`来分配内存时，如下语句只能在C编译器下编译通过:       

     int *p = malloc(10);
而改为如下语句时，则在C、C++编译器下都可以编译通过:    

    int *p = (int*)malloc(10);
<hr /><br /> 
**5)**下面的程序在C编译器下可以编译通过，但是在C++编译器下会导致编译失败。C++中，对常量进行初始化是必须的，但是在C中，并不要求一定对常量进行初始.   

    #include<stdio.h>
    
    int main()
    {
    	const int a;
    	return 0;
    }
<hr /><br />
**6)**C++相对于C而言有着更强的类型检查。例如下面的例子中，在C编译器下虽然有警告，但仍会编译通过，而在C++编译器下，会得到"invalid conversion from int to 'char*'"的错误:     
 
    #include<stdio.h>
    int main()
    {
    	char *c = 300;
    	printf("c = %u",c);
    	return 0;
    }
<hr /><br />
**7)**这一种情况是最容易理解的一种情况，即在C程序中使用C++的关键字，则使用C++编译器时会导致编译失败,如下:     

    #include<stdio.h>
    int main()
    {
    	int new = 3;
    	return 0;
    }
<br />   
一如既往，如果你对文章中的内容有任何疑问，或者是发现文章中有任何错误，都可以通过下面的地址发邮件告诉我.    
E-mail: rytubuntulinux@gmail.com <br /><br />
