# 整数溢出与检测            
2016-06-18  <br /><br />

## 溢出的概念
&nbsp;&nbsp;&nbsp;&nbsp;C/C++ 中有两类整数算术运算 —— 有符号运算与无符号运算。对于有符号运算，存在 **溢出** 的概念，即运算的结果超过了 **2<sup>n</sup>**，其中 **n** 为用来表示整数的位数；在 C 中，有符号数溢出会导致未定义的行为。而对于无符号运算来说，并不存在 **溢出** 的概念，这是因为在 C/C++ 中，无符号运算都是以 **2<sup>n</sup>** (同样 **n** 为用来表示整数的位数) 为模。例如，在以32位来表示整数的系统中，无符号运算的结果为 **expr % 2<sup>32</sup>**, 这里 **expr** 为无符号运算的表达式。       
参阅 **[这里](https://www.gnu.org/software/autoconf/manual/autoconf-2.63/html_node/Integer-Overflow-Basics.html)** 来了解更多 C 中关于整数溢出的概念。      

## 检测是否溢出       
&nbsp;&nbsp;&nbsp;&nbsp;C 标准中规定有符号运算结果溢出会导致未定义的行为(Undefined behavior),因此，对于结果较大的有符号运算，有必要对运算的结果进行检测，以判断其结果是否溢出，下面是两种用来检测的方法。       
   
### 方法一      
对于两个有符号数 `a` 和 `b`,要判断它们相加的结果是否溢出，可以首先将 `a` 和 `b` 转换为无符号整数，之后再与 **INT_MAX** 进行比较，如下:       
     
```cpp
if(unsigned(a)+unsigned(b) > INT_MAX)
{
	// 结果溢出
	...
}
```
其中 **INT_MAX** 是一个定义在头文件 **<limits.h>** 或 **\<climits\>** 中的宏，用来表示有符号数的最大值。             
          
### 方法二           
仍然以两个有符号整数 `a` 和 `b` 相加作为例子，下面是一种不需要将 `a` 和 `b` 转换为无符号数的方法:             
      
```cpp
if(a > INT_MAX-b)
{
	// 结果溢出
	...
}
```
